/*
 * #%L
 * seat-reservation
 * %%
 * Copyright (C) 2025 Felix Hertweck
 * %%
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * #L%
 */
package de.felixhertweck.seatreservation.utils;

import java.security.SecureRandom;
import java.util.HashSet;
import java.util.Set;

import static org.junit.jupiter.api.Assertions.*;

import org.junit.jupiter.api.Test;

class SecurityUtilsTest {

    @Test
    void getSecureRandom_ReturnsNonNull() {
        SecureRandom result = SecurityUtils.getSecureRandom();
        assertNotNull(result, "getSecureRandom should return a non-null SecureRandom instance");
    }

    @Test
    void getSecureRandom_ReturnsSameInstance() {
        SecureRandom first = SecurityUtils.getSecureRandom();
        SecureRandom second = SecurityUtils.getSecureRandom();
        assertSame(first, second, "getSecureRandom should return the same instance");
    }

    @Test
    void generateRandomBytes_ReturnsCorrectLength() {
        int length = 16;
        byte[] result = SecurityUtils.generateRandomBytes(length);
        assertEquals(
                length, result.length, "Generated byte array should have the requested length");
    }

    @Test
    void generateRandomBytes_ReturnsNonNullArray() {
        byte[] result = SecurityUtils.generateRandomBytes(10);
        assertNotNull(result, "generateRandomBytes should return a non-null array");
    }

    @Test
    void generateRandomBytes_GeneratesRandomValues() {
        byte[] first = SecurityUtils.generateRandomBytes(16);
        byte[] second = SecurityUtils.generateRandomBytes(16);
        assertNotEquals(
                java.util.Arrays.hashCode(first),
                java.util.Arrays.hashCode(second),
                "Consecutive calls should generate different random values");
    }

    @Test
    void generateRandomBytes_HandlesDifferentLengths() {
        byte[] small = SecurityUtils.generateRandomBytes(1);
        byte[] medium = SecurityUtils.generateRandomBytes(16);
        byte[] large = SecurityUtils.generateRandomBytes(256);

        assertEquals(1, small.length, "Should handle small length");
        assertEquals(16, medium.length, "Should handle medium length");
        assertEquals(256, large.length, "Should handle large length");
    }

    @Test
    void generateRandomBytes_HandlesZeroLength() {
        byte[] result = SecurityUtils.generateRandomBytes(0);
        assertEquals(0, result.length, "Should handle zero length");
    }

    @Test
    void nextInt_ReturnsValueWithinBound() {
        int bound = 100;
        for (int i = 0; i < 100; i++) {
            int result = SecurityUtils.nextInt(bound);
            assertTrue(result >= 0, "Result should be >= 0");
            assertTrue(result < bound, "Result should be < bound");
        }
    }

    @Test
    void nextInt_GeneratesVariedValues() {
        Set<Integer> values = new HashSet<>();
        int bound = 100;
        for (int i = 0; i < 100; i++) {
            values.add(SecurityUtils.nextInt(bound));
        }
        assertTrue(
                values.size() > 50,
                "Should generate varied values (got " + values.size() + " unique values)");
    }

    @Test
    void nextInt_HandlesSmallBound() {
        int bound = 2;
        for (int i = 0; i < 100; i++) {
            int result = SecurityUtils.nextInt(bound);
            assertTrue(result >= 0 && result < bound, "Result should be within [0, 2)");
        }
    }

    @Test
    void nextLong_ReturnsNonNull() {
        long result = SecurityUtils.nextLong();
        assertNotNull(result, "nextLong should return a value");
    }

    @Test
    void nextLong_GeneratesDifferentValues() {
        long first = SecurityUtils.nextLong();
        long second = SecurityUtils.nextLong();
        long third = SecurityUtils.nextLong();

        // Very unlikely to get the same value twice
        assertTrue(
                first != second || second != third,
                "Consecutive calls should generate different values");
    }

    @Test
    void nextLong_GeneratesVariedValues() {
        Set<Long> values = new HashSet<>();
        for (int i = 0; i < 100; i++) {
            values.add(SecurityUtils.nextLong());
        }
        assertTrue(
                values.size() > 95,
                "Should generate varied values (got " + values.size() + " unique values)");
    }

    @Test
    void constructor_ThrowsException() {
        try {
            var constructor = SecurityUtils.class.getDeclaredConstructor();
            constructor.setAccessible(true);
            constructor.newInstance();
            fail("Constructor should throw UnsupportedOperationException");
        } catch (Exception e) {
            // InvocationTargetException wraps the actual exception
            Throwable cause = e.getCause();
            assertNotNull(cause, "Exception should have a cause");
            assertTrue(
                    cause instanceof UnsupportedOperationException,
                    "Cause should be UnsupportedOperationException");
            assertEquals(
                    "Utility class cannot be instantiated",
                    cause.getMessage(),
                    "Exception message should match");
        }
    }
}
